<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Leap Frogger - Impossible Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #333;
            margin: 0;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            background-color: #000;
            border: 2px solid white;
        }
        #game-container {
            text-align: center;
        }
        #instructions {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="instructions">Use arrow keys to move. Don't fall in the water! Platforms quantum-shift every 1.5s!</div>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const FROG_SIZE = 20;
        const LANE_HEIGHT = 40;
        const NUM_LANES = CANVAS_HEIGHT / LANE_HEIGHT;
        const SHIFT_INTERVAL = 1500; // 1.5 seconds

        let frog = {
            x: CANVAS_WIDTH / 2 - FROG_SIZE / 2,
            y: CANVAS_HEIGHT - FROG_SIZE - 5,
            width: FROG_SIZE,
            height: FROG_SIZE,
            speedX: 0,
            speedY: 0
        };

        let lanes = [];
        let score = 0;
        let gameOver = false;

        // Initialize lanes
        function initLanes() {
            for (let i = 1; i < NUM_LANES - 1; i++) { // Exclude start and end zones
                lanes.push({
                    y: i * LANE_HEIGHT,
                    type: i % 2 === 0 ? 'log' : 'lilypad',
                    platforms: generatePlatforms(i % 2 === 0 ? 'log' : 'lilypad')
                });
            }
        }

        // Generate a random set of platforms for a lane
        function generatePlatforms(type) {
            const platforms = [];
            const platformCount = Math.floor(Math.random() * 4) + 2; // 2 to 5 platforms
            const platformSize = type === 'log' ? 80 : 40;
            for (let i = 0; i < platformCount; i++) {
                platforms.push({
                    x: Math.random() * (CANVAS_WIDTH - platformSize),
                    width: platformSize
                });
            }
            return platforms;
        }

        // Quantum shift function
        function quantumShift() {
            lanes.forEach(lane => {
                lane.platforms = generatePlatforms(lane.type);
            });
        }

        // Set interval for shifting platforms
        setInterval(quantumShift, SHIFT_INTERVAL);

        // Draw everything
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw safe zones (start and end)
            ctx.fillStyle = '#006400'; // Dark green for grass
            ctx.fillRect(0, 0, CANVAS_WIDTH, LANE_HEIGHT);
            ctx.fillRect(0, CANVAS_HEIGHT - LANE_HEIGHT, CANVAS_WIDTH, LANE_HEIGHT);

            // Draw water lanes
            ctx.fillStyle = '#000080'; // Navy for water
            for (let i = 1; i < NUM_LANES - 1; i++) {
                ctx.fillRect(0, i * LANE_HEIGHT, CANVAS_WIDTH, LANE_HEIGHT);
            }

            // Draw platforms
            lanes.forEach(lane => {
                lane.platforms.forEach(platform => {
                    ctx.fillStyle = lane.type === 'log' ? '#8B4513' : '#32CD32'; // Brown for log, lime green for lilypad
                    ctx.fillRect(platform.x, lane.y + 5, platform.width, LANE_HEIGHT - 10);
                });
            });

            // Draw frog
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(frog.x, frog.y, frog.width, frog.height);

            // Draw score and game status
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Score: ' + score, 10, 30);

            if (gameOver) {
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                ctx.font = '20px Arial';
                ctx.fillText('Refresh to play again', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
            }
        }

        // Check for collisions and game logic
        function update() {
            if (gameOver) return;

            // Check water collision (if not on a platform)
            let onPlatform = false;
            if (frog.y > LANE_HEIGHT && frog.y < CANVAS_HEIGHT - LANE_HEIGHT) {
                const currentLane = lanes.find(lane => frog.y >= lane.y && frog.y < lane.y + LANE_HEIGHT);
                if (currentLane) {
                    for (const platform of currentLane.platforms) {
                        if (frog.x >= platform.x && frog.x + frog.width <= platform.x + platform.width) {
                            onPlatform = true;
                            break;
                        }
                    }
                    if (!onPlatform) {
                        gameOver = true;
                        return;
                    }
                }
            }

            // Check goal
            if (frog.y <= 0) {
                score++;
                resetFrog();
            }

            // Keep frog within canvas bounds
            if (frog.x < 0) frog.x = 0;
            if (frog.x + frog.width > CANVAS_WIDTH) frog.x = CANVAS_WIDTH - frog.width;
        }

        // Reset frog to start
        function resetFrog() {
            frog.x = CANVAS_WIDTH / 2 - FROG_SIZE / 2;
            frog.y = CANVAS_HEIGHT - FROG_SIZE - 5;
        }

        // Handle input
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;

            switch (e.key) {
                case 'ArrowUp':
                    frog.y -= LANE_HEIGHT;
                    break;
                case 'ArrowDown':
                    frog.y += LANE_HEIGHT;
                    break;
                case 'ArrowLeft':
                    frog.x -= FROG_SIZE;
                    break;
                case 'ArrowRight':
                    frog.x += FROG_SIZE;
                    break;
            }
        });

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        initLanes();
        gameLoop();

    </script>
</body>
</html>
